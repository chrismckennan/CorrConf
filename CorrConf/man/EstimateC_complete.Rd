\name{EstimateC_complete}
\alias{EstimateC_complete}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{
Estimate the latent factors, C
}
\description{
Estimate the latent factors, C, by first estimating the part of C orthogonal to X and then the part of C in the image of X.
}
\usage{
EstimateC_complete(Y, K, X = NULL, Z = NULL, B = NULL, Cperp = NULL, rho = NULL, return.all = T, EstVariances = F, simpleDelta = F, tol.rho = 0.001, max.iter.rho = 15, svd.method = "fast")
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{Y}{
A p x n data matrix; p = number of units (i.e. genes), n = sample size
}
  \item{K}{
The number of columns of C, i.e. the dimension of the subspace generated by the columns of C
}
  \item{X}{
An n x d matrix of the covariates of interest
}
  \item{Z}{
An n x r matrix of nuisance covariates, like the intercept
}
  \item{B}{
A list of n x n positive semi-definite relatedness matrices if b > 1 or a matrix if b = 1.
}
  \item{Cperp}{
The part of C in the space orthogonal to X. It is assumes Z has been rotated out, if present
}
  \item{rho}{
A b-vector of correlation coefficients
}
  \item{return.all}{
If TRUE, the function will return all values of Cperp and rho for k = 0, 1, ..., K.
}
  \item{EstVariances}{
If TRUE, the function estimates sigma_{0,g}^2 and sigma_{1,g}^2. As of now, this only works when b = 1
}
  \item{simpleDelta}{
How Cperp should be estimated. If TRUE, Delta = delta^2 * I_p
}
  \item{tol.rho}{
Each iteration of sequential PCA completes when ||rho_j - rho_{j-1}||_2 <= b * tol.rho
}
  \item{max.iter.rho}{
Maximum number of iterations j for each sequential PCA iteration
}
  \item{svd.method}{
"fast": uses the package \code{irlba} for svd; any other options uses the R default.
}
}
\details{
%%  ~~ If necessary, more details than the description above ~~
}
\value{
\item{X}{The design matrix}
\item{Z}{The nuisance covariates}
\item{Cperp}{The part of C orthogonal to X, with Z rotated out}
\item{rho}{The correlation coefficients corresponding to each relatedness matrix B_i, i = 1,...,b}
\item{Omega.GLS}{An estimate of (X'V^{-1}X)^{-1}X'V^{-1}C}
\item{C}{An estimate of C}
}
\references{
%% ~put references to the literature/web site here ~
}
\author{
Chris McKennan
}
\note{
%%  ~~further notes~~
}

%% ~Make other sections like Warning with \section{Warning }{....} ~

\seealso{
%% ~~objects to See Also as \code{\link{help}}, ~~~
}
\examples{
##---- Should be DIRECTLY executable !! ----
##-- ==>  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (Y, K, X = NULL, Z = NULL, B = NULL, Cperp = NULL, rho = NULL, 
    return.all = T, EstVariances = F, simpleDelta = F, tol.rho = 0.001, 
    max.iter.rho = 15, svd.method = "fast") 
{
    if (is.null(X)) {
        out <- EstimateCperp(Y = Y, K = K, X = X, Z = Z, B = B, 
            simpleDelta = simpleDelta, return.all = T, tol.rho = tol.rho, 
            max.iter.rho = max.iter.rho, svd.method = svd.method)
        out$X <- X
        out$Z <- Z
        if (!is.null(Z)) {
            Q.Z <- qr.Q(qr(Z), complete = T)[, (ncol(Z) + 1):nrow(Z)]
            out$C.all <- lapply(out$C, function(C) {
                if (is.null(C)) {
                  return(C)
                }
                Q.Z \%*\% C
            })
        }
        else {
            out$C.all <- out$C
        }
        out$C <- out$C.all[[K + 1]]
        out$Cperp <- NULL
        return(out)
    }
    out <- list()
    out$rho <- rho
    out$Sigma.e <- NULL
    out$Sigma.b <- NULL
    out$X <- X
    out$Z <- Z
    out$Cperp <- Cperp
    if (is.null(Cperp) || (!is.null(B) && is.null(rho))) {
        out.perp <- EstimateCperp(Y = Y, K = K, X = X, Z = Z, 
            B = B, simpleDelta = simpleDelta, return.all = return.all, 
            tol.rho = tol.rho, max.iter.rho = max.iter.rho, svd.method = svd.method)
        out$Cperp <- out.perp$C
        if (return.all) {
            Cperp <- out.perp$C[[K + 1]]
        }
        else {
            Cperp <- out.perp$C
        }
        if (is.null(rho)) {
            out$rho <- out.perp$rho
            if (return.all) {
                if (is.matrix(out.perp$rho)) {
                  rho <- out.perp$rho[K + 1, ]
                }
                else {
                  rho <- out.perp$rho[K + 1]
                }
            }
            else {
                rho <- out.perp$rho
            }
        }
    }
    if (is.list(B) && length(B) == 1) {
        B <- B[[1]]
    }
    if (!is.null(Z)) {
        Q.Z <- qr.Q(qr(Z), complete = T)[, (ncol(Z) + 1):nrow(Z)]
        X <- t(Q.Z) \%*\% X
        Y <- Y \%*\% Q.Z
        if (!is.null(B)) {
            if (is.list(B)) {
                B <- lapply(B, function(x) {
                  t(Q.Z) \%*\% x \%*\% Q.Z
                })
            }
            else {
                B <- t(Q.Z) \%*\% B \%*\% Q.Z
            }
        }
    }
    p <- nrow(Y)
    n <- ncol(Y)
    d <- ncol(X)
    Q.X <- qr.Q(qr(X), complete = T)[, (d + 1):n]
    V <- EstimateV.complete(rho, B)
    V.tilde <- t(Q.X) \%*\% V \%*\% Q.X
    V.tilde.inv <- solve(V.tilde)
    sqrt.V.tilde <- sqrt.mat(V.tilde.inv)
    Y2 <- Y \%*\% Q.X \%*\% sqrt.V.tilde
    Cperp.reduced <- sqrt.V.tilde \%*\% t(Q.X) \%*\% Cperp
    var.mat <- solve(t(Cperp.reduced) \%*\% Cperp.reduced)
    L.hat <- Y2 \%*\% Cperp.reduced \%*\% var.mat
    Resids2 <- Y2 - L.hat \%*\% t(Cperp.reduced)
    Delta.hat <- rowSums(Resids2^2)/(n - d - K)
    Y1 <- Y \%*\% solve(V, X) \%*\% solve(t(X) \%*\% solve(V, X))
    out$Omega.GLS <- solve(t(L.hat/Delta.hat) \%*\% L.hat - p * 
        var.mat, t(L.hat/Delta.hat) \%*\% Y1)
    out$C <- X \%*\% t(out$Omega.GLS) + V \%*\% Q.X \%*\% solve(t(Q.X) \%*\% 
        V \%*\% Q.X, t(Q.X) \%*\% Cperp)
    if (!is.null(Z)) {
        out$C <- Q.Z \%*\% out$C
    }
    if (EstVariances && is.matrix(B)) {
        inv.sqrtV.X <- sqrt.mat2((1 - rho) * diag(n - d) + rho * 
            t(Q.X) \%*\% B \%*\% Q.X)$Rinv
        Cperp.inv.X <- inv.sqrtV.X \%*\% t(Q.X) \%*\% Cperp
        Y2 <- Y \%*\% (Q.X \%*\% inv.sqrtV.X)
        L.0 <- Y2 \%*\% (Cperp.inv.X \%*\% solve(t(Cperp.inv.X) \%*\% 
            Cperp.inv.X))
        Resids <- Y2 - L.0 \%*\% t(Cperp.inv.X)
        Delta <- rowSums(Resids^2)/(n - d - K)
        rm(Resids, Y2, L.0)
        out.var <- Gene.Variances_turbo(Y = Y, Cov = cbind(X, 
            Cperp), B = B, Sigma.start = (1 - rho) * Delta, Sigma.b.start = rho * 
            Delta, tol = 1e-06)
        out$Sigma.e <- out.var$Sigma.0
        out$Sigma.b <- out.var$Sigma.b
    }
    return(out)
  }
}
% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
\keyword{ Factor analysis }
