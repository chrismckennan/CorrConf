\name{EstimateCperp}
\alias{EstimateCperp}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{
Compute Cperp
}
\description{
Estimate the part of Q.Z' C orthogonal to Q.Z' X, where Q.Z is an n x (n-r) matrix whose columns form an orthogonal basis for ker(Z'). The user should supply the expression matrix, Y, the number of columns of C, K, the observed covariates of interest, X, the observed nuisance covariates, Z, and the list (or matrix if b = 1) of relatedness matrices.
}
\usage{
EstimateCperp(Y, K, X = NULL, Z = NULL, B = NULL, simpleDelta = F, return.all = T, tol.rho = 0.001, max.iter.rho = 15, svd.method = "fast")
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{Y}{
A p x n data matrix; p = number of units (i.e. genes), n = sample size
}
  \item{K}{
The number of columns of C, i.e. the dimension of the subspace generated by the columns of C
}
  \item{X}{
An n x d matrix of the covariates of interest
}
  \item{Z}{
An n x r matrix of nuisance covariates, like the intercept
}
  \item{B}{
A list of n x n positive semi-definite relatedness matrices is b > 1 or a matrix if b = 1.
}
  \item{simpleDelta}{
If \code{TRUE}, then it assumes Delta = delta^2 * I_p. Otherwise, Delta = diag(delta_1^2,...,delta_p^2). We recommend the user assign this \code{TRUE} for datasets with large p and n, i.e. 800K methylation array data. Otherwise, the program will be slow.
}
  \item{return.all}{
If TRUE, the function will return all values of Cperp and rho for k = 0, 1, ..., K.
}
  \item{tol.rho}{
Each iteration of sequential PCA completes when ||rho_j - rho_{j-1}||_2 <= b * tol.rho
}
  \item{max.iter.rho}{
Maximum number of iterations j for each sequential PCA iteration
}
  \item{svd.method}{
"fast": uses the package \code{irlba} for svd; any other options uses the R default.
}
}
\details{
%%  ~~ If necessary, more details than the description above ~~
}
\value{
\item{K}{The latent dimensions considered, k = 0,1,...,K}
\item{C}{A list of length K+1 who's entries contain the part of C orthogonal to X, with Z rotated out, when the image of C is assumed to have dimension k = 0,1,...,K}
\item{rho}{A b x (K+1) matrix or (K+1) vector containing the correlation coefficients for each B_i}
}
\references{
%% ~put references to the literature/web site here ~
}
\author{
Chris McKennan
}
\note{
%%  ~~further notes~~
}

%% ~Make other sections like Warning with \section{Warning }{....} ~

\seealso{
%% ~~objects to See Also as \code{\link{help}}, ~~~
}
\examples{
##---- Should be DIRECTLY executable !! ----
##-- ==>  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (Y, K, X = NULL, Z = NULL, B = NULL, simpleDelta = F, 
    return.all = T, tol.rho = 0.001, max.iter.rho = 15, svd.method = "fast") 
{
    out <- list()
    out$K <- K
    out$rho <- NULL
    out$C <- NULL
    p <- nrow(Y)
    if (is.list(B) && length(B) == 1) {
        B <- B[[1]]
    }
    if (!is.null(Z)) {
        Q.Z <- qr.Q(qr(Z), complete = T)[, (ncol(Z) + 1):nrow(Z)]
        X <- t(Q.Z) \%*\% X
        Y <- Y \%*\% Q.Z
        if (!is.null(B)) {
            if (is.list(B)) {
                B <- lapply(B, function(x) {
                  t(Q.Z) \%*\% x \%*\% Q.Z
                })
            }
            else {
                B <- t(Q.Z) \%*\% B \%*\% Q.Z
            }
        }
    }
    if (!is.null(X)) {
        Q.X <- qr.Q(qr(X), complete = T)[, (ncol(X) + 1):nrow(X)]
    }
    if (is.null(B)) {
        max.iter.svd <- 3
        if (!is.null(X)) {
            Y <- Y \%*\% Q.X
        }
        n <- ncol(Y)
        for (i in 1:max.iter.svd) {
            if (i == 1) {
                if (svd.method == "fast") {
                  s.i <- irlba(A = Y, nv = K, tol = 1/sqrt(n) * 
                    1e-04)
                }
                else {
                  s.i <- svd(Y)
                }
            }
            else {
                if (svd.method == "fast") {
                  s.i <- irlba(A = Y/sqrt(Sigma), nv = K, tol = 1/sqrt(n) * 
                    1e-04)
                }
                else {
                  s.i <- svd(Y/sqrt(Sigma))
                }
            }
            C.i <- cbind(s.i$v[, 1:K])
            if (i < max.iter.svd) {
                R.i <- Y - Y \%*\% C.i \%*\% solve(t(C.i) \%*\% C.i, 
                  t(C.i))
                Sigma <- 1/(n - K) * rowSums(R.i^2)
            }
            else {
                out$C <- C.i
                if (!is.null(X)) {
                  out$C <- Q.X \%*\% out$C
                }
            }
        }
        return(out)
    }
    if (is.matrix(B)) {
        if (simpleDelta) {
            out.1 <- Optimize.Theta.simrho.full(SYY = 1/p * t(Y) \%*\% 
                Y, X = X, B = B, maxK = K, tol.rho = tol.rho, 
                max.iter.rho = max.iter.rho, svd.method = svd.method)
        }
        else {
            out.1 <- Optimize.Theta.full(Y = Y, K = K, B = B, 
                Cov = X, tol.rho = tol.rho, max.iter.rho = max.iter.rho, 
                svd.method = svd.method)
        }
        if (return.all) {
            out$C <- out.1$C
            out$K <- 0:K
            out$rho <- out.1$rho
            names(out$C) <- out$K
            names(out$rho) <- out$K
        }
        else {
            out$C <- out.1$C[[K + 1]]
            out$rho <- out.1$rho[K + 1]
        }
        return(out)
    }
    if (is.list(B)) {
        if (simpleDelta) {
            out.1 <- Optimize.Theta.multB.simrho(SYY = 1/p * 
                t(Y) \%*\% Y, maxK = K, B = B, Cov = X, tol.rho = tol.rho, 
                max.iter.rho = max.iter.rho, svd.method = svd.method)
        }
        else {
            out.1 <- Optimize.Theta.multB(Y = Y, maxK = K, B = B, 
                Cov = X, tol.rho = tol.rho, max.iter.rho = max.iter.rho, 
                svd.method = svd.method)
        }
        if (!is.null(X)) {
            out.1$C <- lapply(out.1$C, function(x, A) {
                if (is.null(x)) {
                  return(NULL)
                }
                return(A \%*\% x)
            }, A = Q.X)
        }
        if (return.all) {
            out$C <- out.1$C
            out$K <- 0:K
            out$rho <- out.1$Rho
            names(out$C) <- out$K
            rownames(out$rho) <- out$K
        }
        else {
            out$C <- out.1$C[[K + 1]]
            out$rho <- out.1$Rho[K + 1, ]
        }
        return(out)
    }
  }
}
% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
\keyword{ Factor analysis }
